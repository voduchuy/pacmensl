/*MIT LicenseCopyright (c) 2020 Huy VoPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE.*/static char help[] = "Test the sensitivity FSP implementation.\n\n";#include <gtest/gtest.h>#include "SensFspSolverMultiSinks.h"#include "pacmensl_test_env.h"using namespace pacmensl;/* * ===================================================================================================================== * TEST FIXTURE: Toggle-switch with time-varying propensities. Only the time-varying factors of the propensity functions are * parameter-dependent. */namespace toggle_cme {/* Stoichiometric matrix of the toggle switch model */arma::Mat<PetscInt> SM{{1, 1, -1, 0, 0, 0},                       {0, 0, 0, 1, 1, -1}};const int nReaction = 6;/* Parameters for the propensity functions */const double ayx{2.6e-3},    axy{6.1e-3},    nyx{3.0e0},    nxy{2.1e0},    kx0{2.2e-3},    kx{1.7e-2},    dx{3.8e-4},    ky0{6.8e-5},    ky{1.6e-2},    dy{3.8e-4};// Function to constraint the shape of the Fspvoid lhs_constr(PetscInt num_species, PetscInt num_constrs, PetscInt num_states, PetscInt *states, int *vals,                void *args) {    for (int i{0}; i < num_states; ++i) {        vals[i * num_constrs] = states[num_species * i];        vals[i * num_constrs + 1] = states[num_species * i + 1];        vals[i * num_constrs + 2] = states[num_species * i] * states[num_species * i + 1];    }}arma::Row<int> rhs_constr{200, 200, 2000};arma::Row<double> expansion_factors{0.2, 0.2, 0.2};// propensity function for toggleint propensity(const int reaction,               const int num_species,               const int num_states,               const PetscInt *X,               double *outputs,               void *args) {    int (*X_view)[2] = ( int (*)[2] ) X;    switch (reaction) {        case 0:            for (int i{0}; i < num_states; ++i) {                outputs[i] = 1.0;            }            break;        case 1:            for (int i{0}; i < num_states; ++i) {                outputs[i] = 1.0 / (1.0 + ayx * pow(PetscReal(X_view[i][1]), nyx));            }            break;        case 2:            for (int i{0}; i < num_states; ++i) {                outputs[i] = PetscReal(X_view[i][0]);            }            break;        case 3:            for (int i{0}; i < num_states; ++i) {                outputs[i] = 1.0;            }            break;        case 4:            for (int i{0}; i < num_states; ++i) {                outputs[i] = 1.0 / (1.0 + axy * pow(PetscReal(X_view[i][0]), nxy));            }            break;        case 5:            for (int i{0}; i < num_states; ++i) {                outputs[i] = PetscReal(X_view[i][1]);            }            break;        default:return -1;    }    return 0;}int t_fun(PetscReal t, int n_coefs, double *outputs, void *args) {    outputs[0] = kx0;    outputs[1] = kx;    outputs[2] = dx;    outputs[3] = ky0;    outputs[4] = ky;    outputs[5] = dy;    return 0;}int dt_fun(int parameter_idx, PetscReal t, int n_coefs, double *outputs, void *args) {    outputs[parameter_idx] = 1.0;    return 0;}}class SensFspToggleTest : public ::testing::Test { protected:  SensFspToggleTest() {}  void SetUp() override {      int n_par = 6;      t_final = 100.0;      fsp_tol = 1.0e-10;      X0 = X0.t();      dp0 = std::vector<arma::Col<PetscReal>>(n_par, arma::Col<PetscReal>({0.0}));      toggle_model = SensModel(6,                               toggle_cme::SM,                               std::vector<int>({0, 1, 2, 3, 4, 5}),                               toggle_cme::t_fun,                               toggle_cme::propensity,                               toggle_cme::dt_fun,                               {{0}, {1}, {2}, {3}, {4}, {5}},                               nullptr,                               {});  }  void TearDown() override {  }  PetscReal t_final, fsp_tol;  arma::Mat<PetscInt> X0{0, 0};  arma::Col<PetscReal> p0 = {1.0};  std::vector<arma::Col<PetscReal>> dp0;  SensModel toggle_model;  arma::Row<int> fsp_size = {1, 1};  arma::Row<PetscReal> expansion_factors = {0.25, 0.25};};TEST_F(SensFspToggleTest, toggle_sens_solve_with_cvode) {    PetscInt ierr;    PetscReal stmp;    SensDiscreteDistribution p_final_bdf;    std::vector<SensDiscreteDistribution> p_snapshots_bdf;    std::vector<PetscReal> tspan;    Vec q;    tspan = arma::conv_to<std::vector<PetscReal>>::from(arma::linspace<arma::Row<PetscReal>>(0.0, t_final, 3));    SensFspSolverMultiSinks fsp(PETSC_COMM_WORLD);    ierr = fsp.SetModel(toggle_model);    ASSERT_FALSE(ierr);    ierr = fsp.SetInitialBounds(fsp_size);    ASSERT_FALSE(ierr);    ierr = fsp.SetExpansionFactors(expansion_factors);    ASSERT_FALSE(ierr);    ierr = fsp.SetInitialDistribution(X0, p0, dp0);    ASSERT_FALSE(ierr);    ierr = fsp.SetUp();    ASSERT_FALSE(ierr);    p_final_bdf = fsp.Solve(t_final, fsp_tol);    fsp.ClearState();    ierr = VecSum(p_final_bdf.p_, &stmp);    ASSERT_FALSE(ierr);    ASSERT_GE(stmp, 1.0 - fsp_tol);    for (int i{0}; i < 6; ++i) {        ierr = VecSum(p_final_bdf.dp_[i], &stmp);        ASSERT_FALSE(ierr);        ASSERT_LE(abs(stmp), 1.0e-6);    }}/* * ===================================================================================================================== * TEST FIXTURE: Pure birth model with constant-birth rate. */class SensFspPoissonTest : public ::testing::Test { protected:  SensFspPoissonTest() {}  void SetUp() override {      auto propensity =          [&](int reaction, int num_species, int num_states, const int *state, PetscReal *output, void *args) {            for (int i{0}; i < num_states; ++i) {                output[i] = 1.0;            }            return 0;          };      auto t_fun = [&](double t, int num_coefs, double *outputs, void *args) {        outputs[0] = lambda;        return 0;      };      auto d_t_fun = [&](int par_idx, double t, int num_coefs, double *outputs, void *args) {        outputs[0] = 1.0;        return 0;      };      poisson_model = SensModel(1,                                stoich_matrix,                                std::vector<int>({0}),                                t_fun,                                propensity,                                d_t_fun,                                {{0}},                                nullptr);  }  void TearDown() override {  }  ~SensFspPoissonTest() {}  SensModel poisson_model;  PetscReal lambda = 2.0;  arma::Mat<int> stoich_matrix = {1};  arma::Mat<int> x0 = {0};  arma::Col<PetscReal> p0 = {1.0};  arma::Col<PetscReal> s0 = {0.0};  arma::Row<int> fsp_size = {5};  arma::Row<PetscReal> expansion_factors = {0.1};  PetscReal t_final{1.0}, fsp_tol{1.0e-7};};TEST_F(SensFspPoissonTest, test_poisson_analytic) {    PetscInt ierr;    PetscReal stmp;    SensDiscreteDistribution p_final;    SensFspSolverMultiSinks fsp(PETSC_COMM_WORLD);    ierr = fsp.SetModel(poisson_model);    ASSERT_FALSE(ierr);    ierr = fsp.SetInitialBounds(fsp_size);    ASSERT_FALSE(ierr);    ierr = fsp.SetExpansionFactors(expansion_factors);    ASSERT_FALSE(ierr);    ierr = fsp.SetInitialDistribution(x0, p0, std::vector<arma::Col<PetscReal>>({s0}));    ASSERT_FALSE(ierr);    ierr = fsp.SetUp();    ASSERT_FALSE(ierr);    p_final = fsp.Solve(t_final, fsp_tol);    fsp.ClearState();    // Check that the solution is close to Poisson    stmp = 0.0;    PetscReal *p_dat;    int num_states;    p_final.GetProbView(num_states, p_dat);    PetscReal pdf;    int n;    for (int i = 0; i < num_states; ++i) {        n = p_final.states_(0, i);        pdf = exp(-lambda * t_final) * pow(lambda * t_final, double(n)) / tgamma(n + 1);        stmp += abs(p_dat[i] - pdf);    }    p_final.RestoreProbView(p_dat);    MPI_Allreduce(&stmp, MPI_IN_PLACE, 1, MPIU_REAL, MPIU_SUM, PETSC_COMM_WORLD);    ASSERT_LE(stmp, fsp_tol);    PetscReal *s_dat;    p_final.GetSensView(0, num_states, s_dat);    for (int i = 0; i < num_states; ++i) {        n = p_final.states_(0, i);        pdf = -t_final * exp(-lambda * t_final) * pow(lambda * t_final, double(n)) / tgamma(n + 1)            + exp(-lambda * t_final) * t_final * pow(lambda * t_final, double(n - 1)) / tgamma(n);        stmp += abs(s_dat[i] - pdf);    }    p_final.RestoreSensView(0, s_dat);    MPI_Allreduce(&stmp, MPI_IN_PLACE, 1, MPIU_REAL, MPIU_SUM, PETSC_COMM_WORLD);    ASSERT_LE(stmp, 1.0e-6);}/* * ===================================================================================================================== * TEST FIXTURE: Bursting-gene (i.e. telegraph) model with time-invariant propensities. */namespace telegraph_cme {/* Stoichiometric matrix of the telegraph model */arma::Mat<PetscInt> SM{{-1, 1, 0, 0},                       {1, -1, 0, 0},                       {0, 0, 1, -1}};/* Parameters for the propensity functions */const double    k01{1.0e-2},    k10{1.0e-1},    kr{10.0},    gamma{1.0};// propensity function for telegraph modelint propensity(const int reaction,               const int num_species,               const int num_states,               const PetscInt *X,               double *outputs,               void *args) {    int (*X_view)[3] = ( int (*)[3] ) X;    switch (reaction) {        case 0:            for (int i{0}; i < num_states; ++i) {                outputs[i] = k01 * X_view[i][0];            }            break;        case 1:            for (int i{0}; i < num_states; ++i) {                outputs[i] = k10 * X_view[i][1];            }            break;        case 2:            for (int i{0}; i < num_states; ++i) {                outputs[i] = kr * X_view[i][1];            }            break;        case 3:            for (int i{0}; i < num_states; ++i) {                outputs[i] = gamma * X_view[i][2];            }            break;        default:return -1;    }    return 0;}// Derivatives of the propensity functions of the telegraph modelint propensity_derivatives(               const int parameter_idx,               const int reaction,               const int num_species,               const int num_states,               const PetscInt *X,               double *outputs,               void *args) {    int (*X_view)[3] = ( int (*)[3] ) X;    switch (parameter_idx){        case 0:            if (reaction == 0){                for (int i{0}; i < num_states; ++i) {                    outputs[i] = X_view[i][0];                }            }            break;        case 1:            if (reaction == 1){                for (int i{0}; i < num_states; ++i) {                    outputs[i] = X_view[i][1];                }            }            break;        case 2:            for (int i{0}; i < num_states; ++i) {                outputs[i] = X_view[i][1];            }            break;        case 3:            for (int i{0}; i < num_states; ++i) {                outputs[i] = X_view[i][2];            }            break;        default:            return -1;    }    return 0;}}class SensFspTelegraphTest : public ::testing::Test { protected:  SensFspTelegraphTest() {}  void SetUp() override {      int n_par = 6;      t_final = 100.0;      fsp_tol = 1.0e-10;      X0 = X0.t();      dp0 = std::vector<arma::Col<PetscReal>>(n_par, arma::Col<PetscReal>({0.0}));      telegraph_model = SensModel(4,                                  telegraph_cme::SM,                                  {},                                  nullptr,                                  telegraph_cme::propensity,                                  nullptr,                                  {},                                  telegraph_cme::propensity_derivatives,                                  {{0}, {1}, {2}, {3}});  }  void TearDown() override {  }  PetscReal t_final, fsp_tol;  arma::Mat<PetscInt> X0{1, 0, 0};  arma::Col<PetscReal> p0 = {1.0};  std::vector<arma::Col<PetscReal>> dp0;  SensModel telegraph_model;  arma::Row<int> fsp_size = {2, 2, 1};  arma::Row<PetscReal> expansion_factors = {0.25, 0.25, 0.25};};TEST_F(SensFspTelegraphTest, telegraph_sens_solve_with_cvode) {    PetscInt ierr;    PetscReal stmp;    SensDiscreteDistribution p_final_bdf;    std::vector<SensDiscreteDistribution> p_snapshots_bdf;    SensFspSolverMultiSinks fsp(PETSC_COMM_WORLD);    ierr = fsp.SetModel(telegraph_model);    ASSERT_FALSE(ierr);    ierr = fsp.SetInitialBounds(fsp_size);    ASSERT_FALSE(ierr);    ierr = fsp.SetExpansionFactors(expansion_factors);    ASSERT_FALSE(ierr);    ierr = fsp.SetInitialDistribution(X0, p0, dp0);    ASSERT_FALSE(ierr);    ierr = fsp.SetUp();    ASSERT_FALSE(ierr);    p_final_bdf = fsp.Solve(t_final, fsp_tol);    fsp.ClearState();    ierr = VecSum(p_final_bdf.p_, &stmp);    ASSERT_FALSE(ierr);    ASSERT_GE(stmp, 1.0 - fsp_tol);    for (int i{0}; i < telegraph_model.num_parameters_; ++i) {        ierr = VecSum(p_final_bdf.dp_[i], &stmp);        ASSERT_FALSE(ierr);        ASSERT_LE(abs(stmp), 1.0e-6);    }}